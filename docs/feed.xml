<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Hong's Blog</title>
<link href="https://hspak.dev/"/>
<updated>October 27, 2024</updated>
<author>
  <name>Hong Shick Pak</name>
</author>
<id>https://hspak.dev/atom.xml</id><entry>
  <title>Why is CI so slow?</title>
  <published>Oct 26, 2024</published>
  <updated>Oct 26, 2024</updated>
  <link href="https://hspak.dev/post/why-is-ci-slow/" type="text/html"/>
  <id>https://hspak.dev/post/why-is-ci-slow/</id>
  <content type="html">
    &lt;p&gt;I believe that containerized CI environments helped the industry move forward.
We have easily reproducable environments for testing and allows companies to
stay relatively platform agnostic. But they're often reeeally slow. It's sad
that most CI improvements have been thanks to tools like &lt;a href=&quot;https://bun.sh/&quot;&gt;bun&lt;/a&gt; or
&lt;a href=&quot;https://astral.sh/blog/uv&quot;&gt;uv&lt;/a&gt; re-thinking package management from the ground
up with performance at the forefront.&lt;/p&gt;
&lt;p&gt;Most CI platforms &lt;a href=&quot;https://circleci.com/&quot;&gt;are&lt;/a&gt;
&lt;a href=&quot;https://github.com/features/actions&quot;&gt;all&lt;/a&gt;
&lt;a href=&quot;https://docs.gitlab.com/runner/&quot;&gt;the&lt;/a&gt; &lt;a href=&quot;https://buildkite.com/&quot;&gt;same&lt;/a&gt;: you
define some YAML-esque file a DAG of containers that run some shell scripts.
These CI platforms can easily run multi-tenant workloads and improve margins
since these container executions are mostly ephemeral. Artifacts are usually
pushed out to an object store like &lt;a href=&quot;https://aws.amazon.com/s3/&quot;&gt;AWS S3&lt;/a&gt;. Most of
them offer a &amp;quot;cache&amp;quot; where they can push and pull from an object store. This is
not really a cache. It's a hack at an attempt to mimic what a cache on local dev
looks like.&lt;/p&gt;
&lt;p&gt;So much of CI time is burned:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Downloading a container, which is often massive to include all necessary tooling.&lt;/li&gt;
&lt;li&gt;Installing dependencies of your project, which is also often also slow.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I wonder why there has not been an attempt (a successful attempt?) of creating a
CI platform that mimics local development environment:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The git repo is &amp;quot;hot&amp;quot;. It'll have the last commit checked out, which will never be that far away from the origin server.
Pulling down the next branch to test should be small incremenatal delta.&lt;/li&gt;
&lt;li&gt;The filesystem persists: the dependencies are already mostly there (mod new changes).
Any cached files generated during builds and tests persist.
There's no slow fetches from an object store.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Of course, a persistent fs allows for bugs to creep up (stale cache not being
invalidated, invalid state not cleaned up, etc.). But this should be the
exception we face, not the default. No developer is blowing their environment
away on every commit. CI shouldn't have to either.&lt;/p&gt;
&lt;p&gt;Food for thought.&lt;/p&gt;
  </content>
</entry>
<entry>
  <title>What if I'm Wrong</title>
  <published>December 28, 2022</published>
  <updated>December 28, 2022</updated>
  <link href="https://hspak.dev/post/what-if-im-wrong/" type="text/html"/>
  <id>https://hspak.dev/post/what-if-im-wrong/</id>
  <content type="html">
    &lt;p&gt;I've spent almost all my career working at startups (so far) and we are always
venturing into the unknown. Everything is an evergreen deployment. Company
processes are being built from bottom up. The product is constantly changing
trajectory. We're doing whatever we can to hit to arbrarily set milestones for
the company. Everything is effectively being bulit under a handful of
&lt;a href=&quot;/post/strong-opinions-loosely-held/&quot;&gt;opinions&lt;/a&gt; from a select set of people.&lt;/p&gt;
&lt;p&gt;And this trickles down as the company grows. Engineering leaders make their best
judgement for technical direction. Product leaders make their best judgement for
feature development. Ops leaders makes their best judgement for company wide
operations. But what if they're wrong? No human is correct 100% percent of the
time. What can leaders do to help mitigate the cost of being wrong?&lt;/p&gt;
&lt;p&gt;What if we remove the leadership context here and just focus on how we might
navigate uncharted territory in general. Let's start from the most naive
strategy. We try a thing, see how it did, recalibrate and try again. Maybe we
can give ourselves a better starting position because of the domain knowledge
we've collected over the years. And sometimes when we recalibrate, we might be
backtracking -- and that should be &lt;em&gt;an accepted strategy of charting the
unknown&lt;/em&gt;. Imaging trying to navigate a maze, but we're not allowed to backtrack.
That's effectively an all-or-nothing strategy. It's all-in on the first,
initiall decision -- and if it's wrong, we fail.&lt;/p&gt;
&lt;p&gt;Now if we step back into the context of leadership, any sign of backtracking is
seen as a wrongdoing. I don't believe that any amount of signal is going to give
us a perfect insight -- we work with probabilities instead (as we do with just
about everything in life). What is difficult is that a leader makes decisions on
behave of many people, and its become absolute blasphemy to be wrong, ever. Part
of the issue is that any decision made by a leader is levered by other folks. If
a founder's founding thesis is wrong, backtracking means putting everyone at the
company out of a job. But on the flipside, it should never be a massive
surprise. Company progress should ba constantly tracked. Large initatives should
be broken down. To go from &amp;quot;everything is fine&amp;quot; to &amp;quot;nevermind&amp;quot; may point to a
never-backtracking mindset.&lt;/p&gt;
&lt;p&gt;There are also just some things in life that aren't reversible or shouldn't be
and that's okay too. No analogy is perfect. Look at Zuck going all-in on VR.
It's a thesis that may take a long time to pan out. It's a large gamble and it's
hard to imagine as a bystander of how exactly Zuck should've broken down the VR
execution. But one of the advantages of software is that its incredibly easy to
build and tear down. Companies should lean into that trait of software and
harness it to allow the company to also be enabled by fast feedback cycles.&lt;/p&gt;
&lt;p&gt;Effectively, I believe that the most effective method of executing (particularly
in a startup sense) is to optimze for quick iterations (I'm sure this will look
very different based on context), and allow backtracking (i.e canceling
projects*, reverting changes, going back to status quo). Everything I listed for
backtracking hurts, but it's better to go in reverse if we're headed for a
cliff.&lt;/p&gt;
&lt;p&gt;* &lt;em&gt;Google might be an exception here because they don't seem to learn at all
from all their canceled projects. There is never a silver bullet!&lt;/em&gt;&lt;/p&gt;
  </content>
</entry>
<entry>
  <title>Working Hard and Working Smart</title>
  <published>November 14, 2022</published>
  <updated>November 14, 2022</updated>
  <link href="https://hspak.dev/post/work-hard-work-smart/" type="text/html"/>
  <id>https://hspak.dev/post/work-hard-work-smart/</id>
  <content type="html">
    &lt;p&gt;Anytime someone on the internet goes &amp;quot;at my company, we grind&amp;quot; -- you get the
angry internet mob at their doorstep telling them how wrong they are. It's
interesting how &amp;quot;taboo&amp;quot; the expectation of working hard as become (in the tech
scene?). I wonder if many of these instances are hyperboles getting taken too
literally or if too many people have been burned from bad management. To be
clear, I have no problems personally with working stable hours each day -- it's
this strange internet group-think of any exception to this to be considered
hearsay.&lt;/p&gt;
&lt;p&gt;Especially in a smaller company, like many startups, there is not a lot of
foundational leverage to work with. It's ground zero -- you're starting from
scratch. And the chances are, if your workstream looks extremely stable --
that's probably thanks to a colleague that gave a shit and went the extra mile
to make it easy for you. And if this was possible with minimal effort, great!
You've probably just hit a career jackpot with well seasoned co-workers.
Cherish that, but also realize that you may be an outlier. Just think, how much
time have others put in work to support that stable workstream you enjoy
day-to-day? How many years of collective experience did it take to curate an
effective workflow and how did it fit so well with your existing team? (I
suppose the exception here could be that the company as a whole moves at such a
slow pace, there is no required sense of urgency whatsoever -- and this is fine!
Different companies require different factors for success, &lt;em&gt;as long as they can
make money&lt;/em&gt;.)&lt;/p&gt;
&lt;p&gt;Otherwise, you're tackling a differently shaped problem -- likely on a weekly
basis. And it takes time, and some skill to break down these problems into more
predictable chunks of work. But nothing is perfect -- far from it really, just
look at how many tech people shit on JIRA and agile in general. Do people
&lt;em&gt;really&lt;/em&gt; hate JIRA or are they just upset at how bad we as humans are at
breaking down problems?&lt;/p&gt;
&lt;p&gt;A lot of online chatter I read conflates working hard and burning out. It's
definitely a &lt;em&gt;management&lt;/em&gt; problem to set the correct set of expectations for
teams to succeed. Different states of a company requires a different set of
variables to optimize for. And while fear of underperforming is a very
demoralizing workplace, a workspace where your effective work hours are
nonexistent is also problematic &lt;em&gt;as an industry&lt;/em&gt;. As with many things in life, a
good balance between these two extremes is probably where a &amp;quot;right&amp;quot; answer lives
for most companies.&lt;/p&gt;
&lt;p&gt;Regarding burn out, I think is a separate issue entirely. There could be a
number of difference factors at play here:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It may be that the higher leveraged work and projects just don't get
recognized at all (the &lt;a href=&quot;https://noidea.dog/glue&quot;&gt;&amp;quot;glue&amp;quot;&lt;/a&gt; work).&lt;/li&gt;
&lt;li&gt;It may due to a mismatch in expectations of responsibilities. Different
companies have their own pace of shipping and transitioning from one end to
the other causes problems.&lt;/li&gt;
&lt;li&gt;It may be that the company is just rotten to the core from bad leadership
where their view of the state of the company is so far removed from reality.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the end, burn out is unique to each employee -- with their own factors and
motivators. It doesn't sit right with me that &amp;quot;working hard&amp;quot; has turned into
this scapegoat. They say you can work &amp;quot;smart&amp;quot;, but what does that even mean?&lt;/p&gt;
&lt;p&gt;Working well from my experience ultimately comes down to &lt;em&gt;time management&lt;/em&gt;. How
are you allocating your time? What does your day look like? Can you identify
previously solved problems? How can you tackle this better next time? What is
the &amp;quot;right&amp;quot; amount of time to allocate to certain things? It's difficult for me
to imagine someone saying they work &amp;quot;smart&amp;quot; without having worked &amp;quot;hard&amp;quot; before.
&amp;quot;Smart&amp;quot; indicates you've been able to establish a better pattern for solving
whatever immediate problem is at hand. You're going to have a hard time modeling
solutions for problems you've never even remotely seen before. Working &amp;quot;smart&amp;quot;
in my eyes is being disciplined about expanding your mental models so that you
can more effectively map new problems against past experiences. And for someone
to find continuous success here, they need to have learned of this in some way,
either through experience or external resources -- both of which take a
non-trivial amount of &lt;strong&gt;dedicated time&lt;/strong&gt;.&lt;/p&gt;
  </content>
</entry>
<entry>
  <title>Strong Opinions, Loosely Held</title>
  <published>November 6, 2022</published>
  <updated>November 6, 2022</updated>
  <link href="https://hspak.dev/post/strong-opinions-loosely-held/" type="text/html"/>
  <id>https://hspak.dev/post/strong-opinions-loosely-held/</id>
  <content type="html">
    &lt;p&gt;How do you strongly hold an opinion... but hold it loosely? I think it's a
poorly worded phrase, but here's how I interpret it.&lt;/p&gt;
&lt;p&gt;An opinion worth holding is one worth defending. Scientific experiments start
with a hypothesis, &lt;em&gt;an informed opinion&lt;/em&gt;. It's an opinion they believe is worth
exploring. Otherwise, why bother and waste time for all parties? Many open
source projects have an RFC process. Why bother submit one when you're willing
to withdraw it at any feedback or criticism?&lt;/p&gt;
&lt;p&gt;But for all of these processes, there needs to be a certain threshold for them
to pass. How much supporting evidence is required to validate a hypothesis? How
much support is required approve an RFC?&lt;/p&gt;
&lt;p&gt;I believe this is where it gets fuzzy, and important. There is no clear answer
for what that threshold is for each instance. It needs to be up to the owner of
that opinion to decide at what point do they concede. The people that I've
enjoyed working with the most excell at this. It's easy to hold constructive
debates and maintain reason. We continuously help and challenge each other to
improve. There's always a dance, a back-and-forth, &lt;em&gt;some conflict&lt;/em&gt;, but a
resolution at the end.&lt;/p&gt;
&lt;p&gt;I think an opinion is kind of like story telling. There's something there, but
it needs to be developed. I like &lt;a href=&quot;https://www.youtube.com/watch?v=RG4WcRAgm7Y&quot;&gt;Dan Harmon's Story
Circle&lt;/a&gt; and it fits fairly well.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(You) This is status quo.&lt;/li&gt;
&lt;li&gt;(Need) You identify an area of improvement, something worth investigating.&lt;/li&gt;
&lt;li&gt;(Go) You form an opinion -- there's some unknown out there that you try to
model through your past experiences.&lt;/li&gt;
&lt;li&gt;(Search) You do some external research to help validate or refuse your
opinion yourself.&lt;/li&gt;
&lt;li&gt;(Find) You think you are correct.&lt;/li&gt;
&lt;li&gt;(Take) You share with someone and they disagree. Or you run an experiment and
it disagrees. You debate, reform your opinion, etc.&lt;/li&gt;
&lt;li&gt;(Return) You reflect back on the results.&lt;/li&gt;
&lt;li&gt;(Change) Your opinion is now different than before, ideally for the better.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As you go through your career, what you really get out of your experience in the
end is a collection of opinions -- &amp;quot;do this, do that&amp;quot;, &amp;quot;this is bad&amp;quot;, &amp;quot;this is
good&amp;quot;. And ultimately, it's your job to make sure that these are the &amp;quot;right&amp;quot;
opinions to hold. So let's help ourselves improve and tread that fine line
between maintaining your opinion and conceding to the other side.&lt;/p&gt;
  </content>
</entry>
<entry>
  <title>Publishing a Go binary to NPM</title>
  <published>May 22, 2022</published>
  <updated>May 22, 2022</updated>
  <link href="https://hspak.dev/post/publish-npm/" type="text/html"/>
  <id>https://hspak.dev/post/publish-npm/</id>
  <content type="html">
    &lt;p&gt;I recently published a Go binary to &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;NPM&lt;/a&gt;, similar to
how &lt;a href=&quot;https://github.com/evanw/esbuild&quot;&gt;esbuild&lt;/a&gt; is a go binary that's also
published to NPM. When I finally understood how publishing NPM packages worked
(on a surface level), I had this... uncanny feeling on how much flexibility NPM
provides to anyone who wants to publish a package.&lt;/p&gt;
&lt;p&gt;It ultimately allows the user to &lt;strong&gt;upload a directory of whatever&lt;/strong&gt; they would like
and write an &lt;strong&gt;arbitary javascript code that is allowed to run on install&lt;/strong&gt;.&lt;/p&gt;
&lt;h3&gt;Publishing Go to NPM&lt;/h3&gt;
&lt;p&gt;The first question may be why I'm bothering to try this in the first place? I
hacked on a &lt;a href=&quot;https://github.com/hspak/gopm3&quot;&gt;weekend project&lt;/a&gt; to &lt;del&gt;spite&lt;/del&gt;
scratch an itch on how much work it would take to replace
&lt;a href=&quot;https://github.com/Unitech/pm2&quot;&gt;pm2&lt;/a&gt; for some basic process &amp;quot;management&amp;quot; for
local dev purposes. I wanted to maintain feature parity for things I cared
about, one of which was ease of installation for JS devs.&lt;/p&gt;
&lt;p&gt;All that was really required to publish an NPM package is to have a directory with
a &lt;code&gt;package.json&lt;/code&gt; file, stick whatever else you'd like in that directory, and use
their CLI tool to publish it to their registry. To break down the full
requirements of publishing Go to NPM, it is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Build the go binaries targetting the OS/Architectures you'd like to support.&lt;/li&gt;
&lt;li&gt;Place the go binaries in the NPM directory.&lt;/li&gt;
&lt;li&gt;Have an install script that checks to see what OS/Arch the requesting system is.&lt;/li&gt;
&lt;li&gt;Have a small javascript shim to run the correct go binary as a child process.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Esbuild goes one step further that this and leverages the &lt;code&gt;optionalDependencies&lt;/code&gt;
feature of NPM to only download the go binary for the exact OS/Arch of the
requesting system. I've opted for the dumb and simple route of just publishing
all the go binaries in the same package.&lt;/p&gt;
&lt;h3&gt;How I Implemented&lt;/h3&gt;
&lt;p&gt;I started with a completely bottoms up approach because I knew nothing about
publishing NPM modules going into this project. But as a result, I think what I
ended up with is the most simple process you could have (though it's not
automated and not really reproducible the way it's setup today).&lt;/p&gt;
&lt;p&gt;First, I have a dedicated &lt;code&gt;npm&lt;/code&gt; directory that represents the skeleton of the
NPM package that will ultimately be published. The things that matter are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;These bits in the &lt;code&gt;package.json&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;  &amp;quot;scripts&amp;quot;: {
    &amp;quot;postinstall&amp;quot;: &amp;quot;node install.js&amp;quot;
  },
  &amp;quot;bin&amp;quot;: {
    &amp;quot;gopm3&amp;quot;: &amp;quot;src/index.js&amp;quot;
  },
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;postinstall&lt;/code&gt; step runs a script to determine which go binary we need to
actually install and delete the rest.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;bin&lt;/code&gt; specifies the entrypoint of the program which is a JS shim to
execute the go binary as a child process.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There is a dumb shell script that builds the go binaries for all the OS/Arch
pairs that we care about and places them in the NPM dir where the
&lt;code&gt;postinstall&lt;/code&gt; script expects them. It then templates out a &lt;code&gt;package.json&lt;/code&gt; just
to update the version. To finish, we tag the git repo and call the &lt;code&gt;npm&lt;/code&gt; CLI
to publish the &lt;code&gt;npm&lt;/code&gt; directory to their registry.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Feel free to check out the &lt;a href=&quot;https://github.com/hspak/gopm3&quot;&gt;project repo&lt;/a&gt; to see
the full picture! (And the &lt;a href=&quot;https://www.npmjs.com/package/@hspak/gopm3&quot;&gt;npm package&lt;/a&gt; itself)&lt;/p&gt;
  </content>
</entry>
<entry>
  <title>Framework Laptop</title>
  <published>November 14, 2021</published>
  <updated>November 14, 2021</updated>
  <link href="https://hspak.dev/post/framework-laptop/" type="text/html"/>
  <id>https://hspak.dev/post/framework-laptop/</id>
  <content type="html">
    &lt;p&gt;I recently purchased the &lt;a href=&quot;https://frame.work&quot;&gt;framework laptop&lt;/a&gt; for personal
use and have been dailying it for almost a month now. It's spec'd as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DIY Edition&lt;/li&gt;
&lt;li&gt;i7-1165G7 (will be referring to this as the tiger lake CPU)&lt;/li&gt;
&lt;li&gt;Intel wifi AX210 no vPro&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.amazon.com/gp/product/B08DKB5LWY&quot;&gt;1 TB SK hynix Gold P31&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.amazon.com/gp/product/B08C4X9VR5&quot;&gt;32 GB Crucial DDR4 3200 MHz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2x USB-C, 1x USB-A, 1x microSD modules&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://guides.frame.work/Guide/Framework+Laptop+DIY+Edition+Quick+Start+Guide/57&quot;&gt;The install process was super easy&lt;/a&gt;,
except for hooking up the tiny connectors for the wifi module. I also recently
got an M1 max macbook for work and the build quality is honestly not far behind.
It's respectable considering it's almost 3x cheaper than the macbook. There are
a couple things I would like to see improved however:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The hinge feels a bit too stiff and wobbles a bit more than I'd like. Compared
to the macbook hinge, it feels lacking.&lt;/li&gt;
&lt;li&gt;The venting is also a bit lacking and the CPU feels like it's choking at times
(though this is probably the consequence of the CPU choice -- more on this
later).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I have Arch linux on it with &lt;a href=&quot;https://github.com/hspak/homelab/blob/master/laptops/fmw&quot;&gt;my own bespoke
installer&lt;/a&gt; and almost
everything &lt;em&gt;just works&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;I'm coming from a Lenovo Thinkpad X1 Carbon Gen 5 so my thoughts will be
baselined from how the Framework laptop performs against it.&lt;/p&gt;
&lt;h3&gt;What Works Well&lt;/h3&gt;
&lt;p&gt;The display is great (though glossy) and the 3:2 aspect ratio is great. I am
running a wayland based window manager and the HiDPI is not an issue -- I had no
problems with scaling. I also love the manual kill switches for the webcam and
microphone.&lt;/p&gt;
&lt;p&gt;The keyboard is also solid and I don't feel any sort of flexing. I do want to
re-iterate that the build quality is great considering they optimized the laptop
for full repairability.&lt;/p&gt;
&lt;p&gt;The Framework team is fairly active on their &lt;a href=&quot;https://community.frame.work/&quot;&gt;community forum&lt;/a&gt;
which is great to see. Some examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;They were proactive about letting users know of the
&lt;a href=&quot;https://community.frame.work/t/using-the-ax210-with-linux-on-the-framework-laptop/1844&quot;&gt;bluetooth issues on linux&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;They're currently working on getting the
&lt;a href=&quot;https://community.frame.work/t/public-beta-test-bios-v3-06-driver-bundle-2021-10-29/10167/100&quot;&gt;bios update support through LVFS&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;What Doesn't Work Well&lt;/h3&gt;
&lt;p&gt;The CPU is super power hungry and I've seen it temporarily pull ~42W of power on
on occasion which spikes the CPU temps to 100C. For sustained load, it seems to
maintain a steady ~28W of power draw and usually hovers around 80C. This wouldn't
necessarily be an issue, but the fan is quite loud when it kicks on and it tends
to kick on more often than I'd like. (Numbers were pulled from &lt;a href=&quot;https://github.com/amanusk/s-tui&quot;&gt;s-tui&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;The tiger lake CPU doesn't &lt;a href=&quot;https://twitter.com/jeremy_soller/status/1335591509207384065?s=20&quot;&gt;suspend well&lt;/a&gt;.
&lt;em&gt;Technically&lt;/em&gt; tiger lake on the Framework does support deep sleep which you can
enable by toggling the method in &lt;code&gt;/sys/power/mem_sleep&lt;/code&gt;, but it seem to cause
resuming to take an absurd amount of time (10+ seconds). You may as well
just poweroff the laptop at that point. For reference, mine boots around 12
seconds pretty consistently:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ systemd-analyze
Startup finished in 7.670s (firmware) + 249ms (loader) + 1.129s (kernel) + 288ms (initrd) + 3.025s (userspace) = 12.364s 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The current (and default) suspend setup eats a significant amount of power.
Anecdotally, it drains 2.5% to 3% of the battery per hour. This is a huge
regression from my Thinkpad which could stay suspended for a week and I still
wouldn't have to worry about battery life. This is probably my biggest complaint
of the laptop.&lt;/p&gt;
&lt;h3&gt;Concluding Thoughts&lt;/h3&gt;
&lt;p&gt;I think the Framework laptop is great, but unless you absolutely need a laptop
today -- I would recommend you wait until there is a better CPU option. The
thermal load combined with the suspend issues make the tiger lake a really
annoying option as a laptop CPU.&lt;/p&gt;
&lt;p&gt;If Framework is able to continue to grow their marketplace and start supporting
more CPU and other components, I think there's zero reason for me to purchase
another laptop. I would love to be able to swap the CPU/mainboard at some point
in the future.&lt;/p&gt;
  </content>
</entry>
<entry>
  <title>New Blog</title>
  <published>Oct 31, 2021</published>
  <updated>Nov 6, 2021</updated>
  <link href="https://hspak.dev/post/new-blog/" type="text/html"/>
  <id>https://hspak.dev/post/new-blog/</id>
  <content type="html">
    &lt;p&gt;Hello world!&lt;/p&gt;
&lt;p&gt;This will now be my third blog re-write and each have only ever had a single
post... The main motivation here was to write a static blog generator in
&lt;a href=&quot;https://ziglang.org/&quot;&gt;Zig&lt;/a&gt;, mostly for learning purposes.&lt;/p&gt;
&lt;p&gt;This was mostly blocked on me writing a markdown parser so I can make it a
somewhat tolerable for writing blog posts. Recently I found out there's already
a &lt;a href=&quot;https://github.com/kivikakk/koino&quot;&gt;popular markdown parser for Zig&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;Now that this is finally shipped, hopefully more posts will follow!&lt;/p&gt;
  </content>
</entry>
</feed>
